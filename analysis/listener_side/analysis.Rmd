---
title: "analysis"
output: html_document
---

## Import modules
```{r}
rm(list = ls())
library(ggplot2)
library(dplyr)
library(tidyr)
library(aida)
library(broom)
library(MASS)
library(brms)
library(cmdstanr)
```

## Load data
```{r}
data <- read.csv("../../data/data_listenerside/data_pilot1.csv")
```


## Basic data

### Participants info

```{r}
# How many participants do we have?
num_participants <- data %>% distinct(submission_id)
print("We have the following number of participants:")
nrow(num_participants)
```


## Descriptive data analysis
```{r}

experiment_condition <- c("high", "info", "low")

# Filter out NA data and sample trial data
data <- data %>%
  mutate(condition = factor(condition, levels = experiment_condition)) %>%
  filter(!is.na(response)) %>%
  filter(condition %in% experiment_condition)

# Encode the responses into conditions
response_code <- c(
  "Student"   = "low",
  "Teacher"   = "high",
  "Principal" = "info"
)

data <- data %>%
  mutate(
    response_condition = response_code[response],
    response_condition = factor(response_condition,
                                levels = experiment_condition)
  )

# Compute count and proportions by condition
descriptive_summary <- data %>%
  group_by(condition, response_condition) %>%
  summarise(
    n = n(),
    .groups = "drop"
  ) %>%
  group_by(condition) %>%
  mutate(
    proportion = n / sum(n)
  ) %>%
  ungroup()

descriptive_summary
```
```{r}
descriptive_wide <- descriptive_summary %>%
  dplyr::select(condition, response_condition, proportion) %>%
  pivot_wider(
    names_from  = response_condition,
    values_from = proportion,
    values_fill = 0
  )

descriptive_wide
```

Sanity check.
```{r}
# all responses mapped?
sum(is.na(data$response_condition))

# proportions sum to 1?
descriptive_summary %>%
  group_by(condition) %>%
  summarise(sum_prop = sum(proportion))
```
```{r}
# Helper for bootstrapping
bootstrap_props_one_condition <- function(df, B = 2000, level = 0.95) {
  # Ensure factor with stable levels
  res_levels <- levels(df$response_condition)
  if (is.null(res_levels)) {
    res_levels <- sort(unique(df$response_condition))
    df <- df %>% mutate(response_condition = factor(response_condition,
                                                    levels = res_levels))
  }
  
  boot_mat <- replicate(B, {
    idx <- sample(seq_len(nrow(df)), replace = TRUE)
    tab <- table(df$response_condition[idx])
    # ensure all levels present
    tab_full <- tab[res_levels]
    tab_full[is.na(tab_full)] <- 0
    as.numeric(tab_full) / length(idx)
  })
  
  alpha <- (1 - level) / 2
  ci_low  <- apply(boot_mat, 1, quantile, probs = alpha)
  ci_high <- apply(boot_mat, 1, quantile, probs = 1 - alpha)
  prop_emp <- as.numeric(table(df$response_condition)[res_levels]) / nrow(df)
  
  tibble(
    response_condition = factor(res_levels, levels = res_levels),
    proportion         = prop_emp,
    ci_low             = ci_low,
    ci_high            = ci_high
  )
}

# Bootstrap proportions with CIs by condition
boot_descriptive <- data %>%
  group_by(condition) %>%
  group_modify(~ bootstrap_props_one_condition(.x)) %>%
  ungroup()

boot_descriptive

# Plot descriptive proportions with CIs
ggplot(boot_descriptive,
       aes(x = condition,
           y = proportion,
           fill = response_condition)) +
  geom_col(position = position_dodge(width = 0.9)) +
  geom_errorbar(
    aes(ymin = ci_low, ymax = ci_high),
    position = position_dodge(width = 0.9),
    width = 0.2
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                     limits = c(0, 1)) +
  labs(
    x = "Experimental condition",
    y = "Proportion of responses",
    fill = "Response type"
  ) +
  theme_aida()
```
## Inferential data analysis

First we try with GLM based analysis. We could for each conditions enocode fit and non-fit.

```{r}
# 1. Fit vs non-fit per trial
data <- data %>%
  mutate(
    fit = if_else(condition == response_condition, 1L, 0L),
    # set reference level (change if you prefer another baseline)
    condition = relevel(condition, ref = "info")
  )

# 2. Descriptive proportions of 'fit' by condition
fit_summary <- data %>%
  group_by(condition) %>%
  summarise(
    n      = n(),
    n_fit  = sum(fit),
    prop_fit = n_fit / n,
    .groups = "drop"
  )

fit_summary
```

```{r}
# Logistic regression: fit ~ condition
glm_fit <- glm(fit ~ condition,
               data   = data,
               family = binomial)

summary(glm_fit)

# Odds ratios with 95% CIs
glm_fit_or <- tidy(glm_fit,
                   conf.int   = TRUE,
                   exponentiate = TRUE)

glm_fit_or
```
Next we try with binomial test:
```{r}
chance <- 1/3

fit_tests <- fit_summary %>%
  rowwise() %>%
  mutate(
    bt = list(binom.test(n_fit, n, p = chance)),
    p_value  = bt$p.value,
    ci_low   = bt$conf.int[1],
    ci_high  = bt$conf.int[2]
  ) %>%
  ungroup() %>%
  dplyr::select(condition, n, n_fit, prop_fit, p_value, ci_low, ci_high)

fit_tests
```

Finally we will try an ordinal logit regression analysis:
```{r}


# Make sure factors are set up correctly
data <- data %>%
  mutate(
    # ordered outcome for brms
    response_ord = factor(
      response_condition,
      levels = c("low", "info", "high"),
      ordered = TRUE
    ),
    # set baseline of condition
    condition = relevel(condition, ref = "info")
  )

table(data$response_ord, data$condition)
```

```{r}

# Priors: fairly weakly informative
priors <- c(
  set_prior("normal(0, 2)", class = "b"),         # effects of condition
  set_prior("normal(0, 5)", class = "Intercept")  # thresholds (cut-points)
)

ord_brms <- brm(
  formula = response_ord ~ condition,
  family  = cumulative("logit"),
  data    = data,
  prior   = priors,
  chains  = 4,
  iter    = 4000,
  warmup  = 2000,
  cores   = 4,
  seed    = 1234,
  backend = "cmdstanr"
)

summary(ord_brms)
```
```{r}
fixef(ord_brms)  # raw posterior summaries on log-odds scale

# Exponentiate to get odds ratios
fixef_ord_or <- exp(fixef(ord_brms)[, c("Estimate", "Q2.5", "Q97.5")])
fixef_ord_or
```
```{r}
new_dat <- data.frame(
  condition = factor(c("info", "high", "low"),
                     levels = levels(data$condition))
)

pred_probs <- fitted(
  ord_brms,
  newdata = new_dat,
  summary = TRUE  # average across posterior draws
)

pred_probs
```


